<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script>
      window.onload = function() {
        let content = document.getElementById("content");
        traversal(content);
        function traversal(node) {
          //对node的处理
          // nodeType 属性返回以数字值返回指定节点的节点类型。
          // 如果节点是元素节点，则 nodeType 属性将返回 1。
          // 如果节点是属性节点，则 nodeType 属性将返回 2。
          if (node && node.nodeType === 1) {
            console.log(node.tagName);
          }
          var i = 0,
            childNodes = node.childNodes,
            item;
          for (; i < childNodes.length; i++) {
            item = childNodes[i];
            if (item.nodeType === 1) {
              //递归先序遍历子节点
              traversal(item);
            }
          }
        }
        function new1(func) {
          let target = {};
          target.__proto__ = func.prototype;
          let res = func.call(target);
          if (typeof res == "object" || typeof res == "function") {
            return res;
          }
          return target;
        }
        function add(a, b) {
          console.log(a + b);
          return a + b;
        }
        function sub(a, b) {
          return a - b;
        }
        Function.prototype.call2 = function(context = window) {
          context.fn = this;
          // let args = [];
          // for(let i=1;i<arguments.length;i++){
          //     args.push("arguments[" + i + "]"); //不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错
          // }
          // args = args.join(",");
          // var result = eval("context.fn(" + args + ")"); //相当于执行了context.fn(arguments[1], arguments[2]);
          var args = [...arguments].slice(1); // 将 context 后面的参数取出来
          var result = context.fn(...args);
          delete context.fn;
          return result; //因为有可能this函数会有返回值return
        };
        Function.prototype.apply2 = function(context = window, arr) {
          context.fn = this;
          // let args = [];
          // let params = arr || [];
          // for(let i=0;i<params.length;i++){
          //     args.push("params[" + i + "]"); //不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错
          // }
          // args = args.join(",");
          // var result = eval("context.fn(" + args + ")"); //相当于执行了context.fn(arguments[1], arguments[2]);
          // 需要判断是否存储第二个参数
          // 如果存在，就将第二个参数展开
          var result;
          if (arguments[1]) {
            result = context.fn(...arguments[1]);
          } else {
            result = context.fn();
          }
          delete context.fn;
          return result; //因为有可能this函数会有返回值return
        };
        console.log(sub.call2(traversal, 1, 2));
        console.log(sub.apply2(traversal, [1, 2]));
        console.log(sub.call(add, 1, 2));
        Function.prototype.bind2 = function(context) {
          let _this = this;
          //   let argsParent = Array.prototype.slice.call(arguments, 1);
          let argsParent = [...arguments].slice(1);
          // console.log(Array.isArray(arguments)); // false
          // let argsParent = arguments.slice(1); // 报错
          console.log(argsParent);
          return function() {
            let args = argsParent.concat(Array.prototype.slice.call(arguments)); //转化成数组
            let a = _this.apply(context, args); // this指向context
            console.log(a);
          };
        };
        console.log(sub.bind2(add)(1, 2));

        function PromiseM(fn) {
          var value = null;
          var callbacks = [];
          //加入状态 为了解决在Promise异步操作成功之后调用的then注册的回调不会执行的问题
          var state = "pending";
          var _this = this;

          // 注册所有回调函数
          this.then = function(fulfilled, rejected) {
            //如果想链式promise 那就要在这边return一个new Promise
            return new PromiseM(function(resolv, rejec) {
              console.log(resolv);
              console.log(rejec);

              //异常处理
              try {
                if (state == "pending") {
                  callbacks.push(fulfilled);
                  //实现链式调用
                  return;
                }
                if (state == "fulfilled") {
                  var data = fulfilled(value);
                  console.log("fulfilled", data);

                  //为了能让两个promise连接起来
                  resolv(data);
                  return;
                }
                if (state == "rejected") {
                  var data = rejected(value);
                  console.log("rejected", data);
                  //为了能让两个promise连接起来
                  rejec(data);
                  return;
                }
              } catch (error) {
                _this.catch(error);
              }
            });
          };
          //执行所有的回调函数
          function resolve(valueNew) {
            value = valueNew;
            state = "fulfilled";
            execute();
          }
          //执行所有的回调函数
          function reject(valueNew) {
            value = valueNew;
            state = "rejected";
            execute();
          }
          function execute() {
            //加入延时机制 防止promise里面有同步函数 导致resolve先执行 then还没注册上函数
            setTimeout(function() {
              callbacks.forEach(function(cb) {
                value = cb(value);
              });
            }, 0);
          }
          this.catch = function(e) {
            console.log(JSON.stringify(e));
          };
          //经典 实现异步回调
          fn(resolve, reject);
        }
        var p = new PromiseM(function(resolve, reject) {
          resolve(1);
          // reject(2)
        });
        p.then(res => {
          console.log("====================================");
          console.log(00, res);
          console.log("====================================");
        });
      };
    </script>
  </head>
  <body>
    <div id="content" class="123" as="12">
      <div class="item">
        <h4>第 1 题：http的状态码中，499是什么？如何出现499，如何排查跟解决</h4>
        <div>
          499对应的是 “client has closed
          connection”，客户端请求等待链接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等得“不耐烦”了。还有一种原因是两次提交post过快就会出现499。
          解决方法： 前端将timeout最大等待时间设置大一些
          nginx上配置proxy_ignore_client_abort on;
          <a
            href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fairuikun%2FWeekly-FE-Interview%2Fissues%2F1"
            >详情</a
          >
        </div>
      </div>
      <div class="item">
        <h4>第 2 题：如何遍历一个dom树</h4>
        <div>
          function traversal(node) { <br />
          //对node的处理 <br />
          if (node && node.nodeType === 1) { <br />
          console.log(node.tagName); <br />
          } <br />
          var i = 0, <br />
          childNodes = node.childNodes, <br />
          item; <br />
          for (; i '<' childNodes.length; i++) { <br />
          item = childNodes[i]; <br />
          if (item.nodeType === 1) { <br />
          //递归先序遍历子节点 <br />
          traversal(item); <br />
          } <br />
          } <br />
          }
        </div>
      </div>
      <div class="item">
        <h4>第 3 题：new操作符都做了什么</h4>
        <div>
          四大步骤： 1、创建一个空对象，并且 this 变量引用该对象，// lat target
          = {}; 2、继承了函数的原型。// target.proto = func.prototype;
          3、属性和方法被加入到 this 引用的对象中。并执行了该函数func//
          func.call(target); 4、新创建的对象由 this 所引用，并且最后隐式的返回
          this 。// 如果func.call(target)返回的res是个对象或者function 就返回它
          function new(func) { <br />
          let target = {}; <br />
          target.__proto__ = func.prototype; <br />
          let res = func.call(target); <br />
          if (typeof(res) == "object" || typeof(res) == "function") { <br />
          return res; <br />
          } <br />
          return target; <br />
          }
        </div>
      </div>
      <div class="item">
        <h4>第 4 题：手写代码，简单实现call</h4>
        <div>
          Function.prototype.call2 = function(context) { <br />
          var context = context || window; //因为传进来的context有可能是null
          <br />
          context.fn = this; <br />
          var args = []; <br />
          for (var i = 1; i < arguments.length; i++) { <br />
          args.push("arguments[" + i + "]"); //不这么做的话
          字符串的引号会被自动去掉 变成了变量 导致报错 <br />
          } <br />
          args = args.join(","); <br />

          var result = eval("context.fn(" + args + ")");
          //相当于执行了context.fn(arguments[1], arguments[2]); <br />

          delete context.fn; <br />
          return result; //因为有可能this函数会有返回值return <br />
          }
        </div>
      </div>
      <div class="item">
        <h4>第 5 题：手写代码，简单实现apply</h4>
        <div></div>
      </div>
      <div class="item">
        <h4>第 6 题：手写代码，简单实现bind</h4>
        <div>
          Function.prototype.bind2 = function(context) { <br />
          var _this = this; <br />
          var argsParent = Array.prototype.slice.call(arguments, 1); <br />
          return function() { <br />
          var args = argsParent.concat(Array.prototype.slice.call(arguments));
          //转化成数组 <br />
          _this.apply(context, args); <br />
          }; <br />
          }
        </div>
      </div>
      <div class="item">
        <h4>第 7 题：讲解一下HTTPS的工作原理</h4>
        <div>
          HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：
          浏览器将自己支持的一套加密规则发送给网站。<br />
          网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
          获得网站证书之后浏览器要做以下工作：<br />
          a)
          验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
          如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。<br />
          使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br />

          网站接收浏览器发来的数据之后要做以下的操作：<br />
          a)
          使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br />
          b) 使用密码加密一段握手消息，发送给浏览器。<br />

          浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
        </div>
      </div>
      <div class="item">
        <h4>第 8 题：讲解一下https对称加密和非对称加密。</h4>
        <div>
          对称加密：<br />
          发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。<br />
          非对称加密：<br />
          接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。
          非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。
        </div>
      </div>
      <div class="item">
        <h4>
          第 9 题： 简单实现项目代码按需加载，例如import { Button } from
          'antd'，打包的时候只打包button
        </h4>
        <div>
          原理很简单，就是将<br />
          import { Select, Pagination, Button } from 'xxx-ui';<br />
          复制代码通过babel转化成<br />
          import Button from `xxx-ui/src/components/ui-base/Button/Button`;<br />
          import Pagination from
          `xxx-ui/src/components/ui-base/Pagination/Pagination`;<br />
          import Select from `xxx-ui/src/components/ui-base/Select/Select`;<br />
          复制代码自定义拓展一个babel插件，代码如下：<br />
          <a
            href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fairuikun%2FWeekly-FE-Interview%2Fissues%2F9"
            >。。。</a
          >
        </div>
      </div>
      <div class="item">
        <h4>第 10 题：简单手写实现promise</h4>
        <div>
          // 简易版本的promise // 第一步： 列出三大块 this.then resolve/reject
          fn(resolve,reject) // 第二步： this.then负责注册所有的函数
          resolve/reject负责执行所有的函数 // 第三步：
          在resolve/reject里面要加上setTimeout 防止还没进行then注册
          就直接执行resolve了 // 第四步： resolve/reject里面要返回this
          这样就可以链式调用了 // 第五步： 三个状态的管理 pending fulfilled
          rejected // *****promise的链式调用 在then里面return一个promise
          这样才能then里面加上异步函数 // 加上了catch
          <a href="https://www.jianshu.com/p/1eea8ce8c7a5">。。。</a>
        </div>
      </div>
    </div>
  </body>
</html>
